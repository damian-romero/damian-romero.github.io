# Self-host your APIs (Series), Part 2: Deploy your API to the public web from your local Ubuntu Server with Raspberry Pi, No-IP.com, Ngnix and Python

Here we will put our Pi on the web using a free service called No-IP.


We will not go deep into any security configuration yet so be mindful that this is only an experiment and you should not be hosting any personal, private, or protected information in your Pi. Also, read my disclaimer at the end of this blog post.


Ubuntu network configuration
https://ubuntu.com/server/docs/network-configuration

Deployment basics
https://fastapi.tiangolo.com/deployment/https/

Reverse-proxy for A Public Website on Your Home Raspberry Pi
https://www.tomshardware.com/how-to/host-public-website-raspberry-pi
https://github.com/rydercalmdown/pi_home_reverse_proxy
https://cloud.google.com/dns/docs/tutorials/create-domain-tutorial
https://cloud.google.com/compute/docs/ip-addresses/reserve-static-external-ip-address


The Easy Way to Host A Website on Your Raspberry Pi
https://www.youtube.com/watch?v=jKZ8XJwckSg&ab_channel=DataSlayer


Raspberry Pi versus AWS // How to host your website on the RPi4
https://www.youtube.com/watch?v=QdHvS0D1zAI&ab_channel=Fireship


Creating A Raspberry Pi Web Server For My Home!
https://www.youtube.com/watch?v=6gkoDQUQSLc&ab_channel=KalleHallden

Linode 
https://www.youtube.com/watch?v=KgAtZ1LlNiQ&ab_channel=Linode


Ngrok
https://ngrok.com/download

https://www.instructables.com/Host-your-website-on-Raspberry-pi/


FastAPI — authentication revisited: Enabling API key authentication
https://nilsdebruin.medium.com/fastapi-authentication-revisited-enabling-api-key-authentication-122dc5975680


How to Deploy a Machine Learning Model
https://towardsdatascience.com/how-to-deploy-a-machine-learning-model-dc51200fe8cf

*Machine learning model serving in Python using FastAPI and streamlit*
https://davidefiocco.github.io/streamlit-fastapi-ml-serving/

Raspberry Pi versus AWS // How to host your website on the RPi4
https://www.youtube.com/watch?v=QdHvS0D1zAI&t=309s&ab_channel=Fireship


Build And Host Fast Data Science Applications Using FastAPI
https://towardsdatascience.com/build-and-host-fast-data-science-applications-using-fastapi-823be8a1d6a0

Firewall stuff. The default Ubuntu firewall is ufw, with is short for “uncomplicated firewall
https://askubuntu.com/questions/295962/how-do-i-access-localhost8080-running-on-ubuntu-from-windows-running-in-virtual
https://stackoverflow.com/questions/37620348/how-do-i-revert-a-ufw-command
https://www.linode.com/docs/guides/configure-firewall-with-ufw/
https://linuxconfig.org/how-to-enable-disable-firewall-on-ubuntu-20-04-lts-focal-fossa-linux
https://www.cyberciti.biz/tips/how-do-i-enable-ufw-in-ubuntu-learn-how-to-protect-your-box.html
https://linuxconfig.org/how-to-open-allow-incoming-firewall-port-on-ubuntu-20-04-focal-fossa

https://www.noip.com/support/knowledgebase/dynamic-dns-ddns-troubleshooting-guide/
https://www.noip.com/support/knowledgebase/general-port-forwarding-guide/

Test your no-ip address:

`nslookup fworks-tests.ddns.net`

Prior to running the rules input through the terminal, UFW will run a file, before.rules, that allows loopback, ping, and DHCP:

```
sudo cat /etc/ufw/before.rules
sudo cat /etc/ufw/before6.rule
sudo cat /etc/ufw/after.rule
sudo cat /etc/ufw/after6.rule
```

sudo ufw start
sudo ufw status | grep -qw active
sudo ufw status verbose
sudo ufw status numbered
sudo ufw delete [number]
sudo ufw show added

sudo ufw allow in 8000
sudo ufw allow out 8000
sudo ufw allow in ssh  # Change /etc/services to control the port number

sudo ufw allow proto tcp from any to any port 22
sudo ufw allow in on eth0 from 192.168.0.0/16
sudo ufw allow out on eth1 to 10.0.0.0/8
sudo ufw route allow in on eth0 out on eth1 to 10.0.0.0/8 from 192.168.0.0/16
sudo ufw limit 2222/tcp comment 'SSH port'



Useful: https://www.portchecktool.com/
https://www.portchecktool.com/ports.php
We'll use the standard port for alternative HTTP connections, port 8080.


Other
Deploy a Secure FastAPI App on Ubuntu 20.04 using Python3.10 / CertBot / Nginx and Gunicorn. https://www.codementor.io/@collinsonyemaobi/deploy-a-secure-fastapi-app-on-ubuntu-20-04-using-python3-10-certbot-nginx-and-gunicorn-1spdjl4suw
Deploy FastAPI on Ubuntu and Serve using Caddy 2 Web Server https://www.tutlinks.com/deploy-fastapi-on-ubuntu-gunicorn-caddy-2/


## Use your own domain (I use Google domains)

Virtual private server
https://www.noip.com/support/knowledgebase/using-your-domain-with-no-ip-plus-when-its-registered-elsewhere/


172.73.1.221
http://172.73.1.221/
fworks-tests.ddns.net


http://fworks-tests.ddns.net/

http://damian_r@fworks-tests.ddns.net

http://fworks-tests.ddns.net:8080

http://fworks-tests.ddns.net:8000

http://172.73.1.221:8080
http://192.168.1.86:8000

https://www.noip.com/support/knowledgebase/can-i-use-my-own-domain-name-with-no-ip/#:~:text=Yes.,s)%20with%20No%2DIP


Host your own website with Raspberri Pi

https://fireship.io/lessons/host-website-raspberry-pi/
https://www.makeuseof.com/tag/host-website-raspberry-pi/
https://pimylifeup.com/raspberry-pi-web-server/
https://pimylifeup.com/raspberry-pi-nginx/
https://projects.raspberrypi.org/en/projects/lamp-web-server-with-wordpress


`ping ns1.no-ip.com`

ns1.no-ip.com
194.62.181.53

ns2.no-ip.com
194.62.180.53

ns3.no-ip.com
204.16.255.53

ns4.no-ip.com
204.16.254.53


How to Setup Plus Managed DNS: https://www.noip.com/support/knowledgebase/how-to-setup-plus-managed-dns/?utm_campaign=product-activation&utm_medium=notice&utm_source=email

Using a Domain with No-IP When It’s Registered Elsewhere: https://www.noip.com/support/knowledgebase/using-your-domain-with-no-ip-plus-when-its-registered-elsewhere/

Learn about Dynamic DNS: https://support.google.com/domains/answer/6147083?hl=en

Manage domain name servers https://support.google.com/domains/answer/3290309?hl=en&ref_topic=9018335

USING DDNS SERVICES WITH SBS 2008/2011 https://blog.lan-tech.ca/tag/no-ip/


IP Addresses for No-IP’s Monitoring Servers https://www.noip.com/support/knowledgebase/what-are-the-ip-addresses-of-the-monitoring-servers-so-i-can-white-list-them-in-my-firewall/


## Nginx

Let's ***suppose you are using localhost:8080*** to run a web server locally with a FastAPI app wither with uvicorn:

```
uvicorn my_app.main:app --host 0.0.0.0 --port 8080
```

Or with guicorn:

```
`gunicorn my_app.main:app --workers 4 --worker-class uvicorn.workers.UvicornWorker --bind 0.0.0.0:8080  # Mi API`
````

We'll manage this process from Nginx. This will help you scale your application later.

First you will need to install Nginx. 

```
sudo apt update
sudo apt upgrade
sudo apt install nginx
```

This will add nginx to the /etc/ directory `lss /etc/nginx/`. Nginx comes with a test website which can be run with:

```
sudo /etc/init.d/nginx start
```

Or you can use the following commands to control your nginx server.

```
sudo systemctl status nginx  # shows status
sudo systemctl start nginx   # starts nginx service
sudo systemctl restart nginx   # starts nginx service
sudo systemctl stop nginx    # stops nginx service
sudo systemctl enable nginx  # Enables nginx during boot, highly recommended
sudo systemctl disable nginx # Disables nginx during boot
```

If you navigate to a web browser in your local network and open your Pi's IP or host name, you will see a simple white website with a heading saying `Welcome to nginx!` which is being served on the standard port 80. This means that `nginx` was successfully installed.

Update Nginx configuration by creating a default config file. We'll do this in `/etc/nginx/sites-available/default`:

```
sudo cp /etc/nginx/sites-available/default /etc/nginx/sites-available/default.old  # do not discard sample config
sudo rm etc/nginx/sites-available/default && sudo nano /etc/nginx/sites-available/default
```

Now copy and paste the following configuration:

```
server {
  listen 80 default_server;
  listen [::]:80 default_server;

  server_name _;

  location / {
    proxy_pass http://localhost:8080;  # Proxy it to our application running on this port
  }
}
```

Now you will be able to receive requests from port 80 even though your FastAPI app is being served on port 8080. From your local network you can do:

```
firecracker/
```

And you will see your FastAPI app.

Resources:
- https://www.nginx.com/resources/wiki/start/
- https://www.nginx.com/resources/wiki/start/topics/tutorials/config_pitfalls/
- https://wiki.debian.org/Nginx/DirectoryStructure
- For detailed examples: /usr/share/doc/nginx-doc/examples/ 
- https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/
- IMPORTANT READ: https://www.nginx.com/resources/wiki/start/topics/tutorials/config_pitfalls/
- A visual guide (the config file may not fit our example) https://www.youtube.com/watch?v=QdHvS0D1zAI&ab_channel=Fireship
- https://dev.to/danielkun/nginx-everything-about-proxypass-2ona 

## FastAPI with Nginx and PM2

https://www.youtube.com/watch?v=t2AXy2y61oE&ab_channel=FullStackBook
https://pm2.keymetrics.io/


## Use third-party service No-IP.com to avoid the need for a static public IP

So far we've been able to access our PI from our Local Area Network via SSH (ssh ubuntu@firecracker). However, we cannot yet do this from outside our home network. We'll set up a secure connection using a third-party service called No-IP.com which allows you to access devices publicly through a dynamic domain name system (DDNS).

In order to access any device in the internet, that device must have a public IP. Your home network is assigned one public IP which is what your router used to connect your local network (LAN) to the public internet. If you'd like to find your public IP, you can search for it in Google by typing "what is my ip?" or following this link: https://www.google.com/search?q=what+is+my+ip

Theoretically you can connect to your local devices from outside your local network using your public IP and a port number. There are two issues with this though:

1. Your public IP address changes constantly. Internet Service Providers (ISPs) use dynamic IP address assignments so your IP will change from time to time. This means that, if you know what your IP address is, you can connect to your devices, but when your public IP changes without you knowing, you will not be able to access your device until you find out what your new public IP is. That is where Dynamic domain name systems (DDNSs) come in. DDNSs find your IP even if it changes. They allow you to create custom host names which can be linked to your devices, that way you connect directly to this host name instead of using an IP. If you'd like to learn more about Dynamic IPs, this short guide explains the basics really well: https://www.noip.com/support/knowledgebase/what-is-a-dynamic-ip-address/

2. Your router's ports are closed. Your router acts like a gateway between your local area network (LAN) and the internet. It will, by default, reject external connections to your devices. Luckily, most routers will let you open ports for the devices you want. This process is called "port forwarding".

No-IP.com will help us solve the first problem by monitoring our IP address constantly so that when it changes, there is an automated update in our No-IP.com account. Inside our No-IP account, we are able to create a static hostname or subdomain and link it to our dynamic IP address. On our side, we need to run a piece of software provided by No-IP.com called "Dynamic Update Client", which you need to install either on your router or on your Pi. The Dynamic Update Client checks for IP changes, it then communicates to No-IP.com who will update your hostname with your new IP address.

Go to https://www.noip.com/, create a free account and a free public hostname. You can only create one for free, but it is enough for an experiment. Mine is `fworks-tests.ddns.net`. For a walkthrough on how to do this, you can watch this video: https://www.youtube.com/watch?v=QdHvS0D1zAI&ab_channel=Fireship


## Install No-IP's Dynamic Update Client (noip2) for Ubuntu

I am not sure why this needs to be run as root and I am only testing this service so if this is also your case I recommend that you do it in a safe environment to minimize any potential risks. Having said that, No-IP seems to be a very commonly used solution and many people seem to trust them. You can read No-Ip's official installation documentation here: https://www.noip.com/support/knowledgebase/installing-the-linux-dynamic-update-client-on-ubuntu/

```shell
sudo -s  # use root
cd /usr/local/src/  
wget http://www.noip.com/client/linux/noip-duc-linux.tar.gz  # Download DUC client software
tar xf noip-duc-linux.tar.gz  # Untar compressed file
cd noip-2.1.9-1/
make install  # Follow the instructions below
```

You will be prompted to log in with your No-IP account email and password. The documentation advises you to install GNU's GCC compiler tools https://gcc.gnu.org/ if you get "make not found" or "missing gcc". Install these, reboot your machine, and run `make install` again. I did not have any troubles with this on a Pi 4B running Ubuntu 22.04.1 LTS.

You will be asked to `Please enter an update interval:[30]`. The question is asking how often you want the IP update to happen. You need to provide a numeric answer where the number represents the interval minutes that the daemon will wait to update your IP. I chose the minimum, which is 5.

You will also get a cryptic question `Do you wish to run something at successful update?`. The question seems to mean if you want to get a notification when the update was successful. I chose 'n' for "no".

If everything goes well, you will see the following output:

```
New configuration file '/tmp/no-ip2.conf' created.
mv /tmp/no-ip2.conf /usr/local/etc/no-ip2.conf
```

Now your configuration file will live in `/usr/local/etc/no-ip2.conf`. You can now access your server with a host name. You can also remove the compressed file by doing `sudo rm noip-duc-linux.tar.gz `

To configure the Dynamic Update Client use root privileges to do:

`/usr/local/bin/noip2 -C`

Again enter your No-IP username and password, as well as the hostnames you wish to update. If you went for the free option, you will only have one hostname which is the one that the program will automatically use. Congratulations! You have installed No-IP's Dynamic Update Client, also known as `noip2`.


## Launch No-IP's Dynamic Update Client (noip2) with the recommended commands

Now that the client is installed and configured, you just need to launch it. Simply issue this final command to launch the client in the background:

```
/usr/local/bin/noip2  # You will need to input your No-IP.com password
```

You will have noticed that, during the installation process, No-IP recommends to use systemctl to start, stop, or check on the status of noip2 as in `systemctl start noip2.service`. I wasn't able to "just run" these commands because I kept getting this error: `Unit noip2.service could not be found.`. Now, I remind you that I am just starting to deep divert into Linux, so I had no idea about services, system.d, etc, but I found a great guide which helped me set them up: https://www.blackmoreops.com/2020/11/18/how-to-install-the-noip2-on-ubuntu-and-run-via-systemd-systemctl-noip-dynamic-update-client/

Following the guide above, here is what I did:

```
nano /etc/systemd/system/noip2.service  # Create noip2 service for systemd
```

Copy the following: 

```
[Unit]
Description=noip2 service

[Service]
Type=forking
ExecStart=/usr/local/bin/noip2
Restart=always

[Install]
WantedBy=default.target
```

now reload the systemctl daemon

```
sudo systemctl daemon-reload
```

The following commands will be available now:

```
sudo systemctl status noip2  # shows status
sudo systemctl start noip2   # starts noip2 service
sudo systemctl stop noip2    # stops noip2 service
sudo systemctl enable noip2  # Enables noip2 during boot
sudo systemctl disable noip2 # Disables noip2 during boot
```



Resources:
- How to Install the Linux Dynamic Update Client on Ubuntu: https://www.noip.com/support/knowledgebase/installing-the-linux-dynamic-update-client-on-ubuntu/
- How to Install the No-IP Dynamic Update Client: https://www.linuxwebzone.com/how-to-install-the-no-ip-dynamic-update-client/
- How to Install the No-IP DUC on a Raspberry Pi: https://www.noip.com/support/knowledgebase/install-ip-duc-onto-raspberry-pi/


https://www.noip.com/about

https://www.noip.com/sign-up


How to Setup and Configure Dynamic DNS (DDNS) in a TP-Link Router
https://www.noip.com/support/knowledgebase/setting-ddns-tp-link-router/


How to Configure DDNS (Dynamic DNS) in a Router
https://www.noip.com/support/knowledgebase/how-to-configure-ddns-in-router/



Resources:

- A short video about DDNSs:  https://www.youtube.com/watch?v=rOLGvZagdC0&ab_channel=PowerCertAnimatedVideos
- 









# Self-host your APIs (Series), Part 0: Customizing my Ubuntu Server 20.04 experience

This blog post series was mainly inspired by `Wolfgang's Channel` selfhosting video series available here: https://www.youtube.com/playlist?list=PLkxWXio1KmRrev61fFuE_0wNj5ZzaEK22

If you want to know why self-hosting might be a good idea for some people, check out this video: https://www.youtube.com/watch?v=gmijwPlD35Q&list=PLkxWXio1KmRrev61fFuE_0wNj5ZzaEK22&index=11&ab_channel=Wolfgang%27sChannel

My reason to self-host is to experiment with some Machine Learning models with colleagues without paying for a dedicated server (we have our own servers which we want to make available to ourselves via public internet for different reasons). We don't use Raspberry Pis to for our Machine Learning models, although I suppose one might be able to use clusters? I only use Raspberry Pis for testing different setups.

Here I will track my customization for Ubuntu Server 20.04 in my Raspberry Pi 4b, 8Gb. I expect to automate all of these things with Ansible in the future: https://www.youtube.com/watch?v=Z7p9-m4cimg&list=PLkxWXio1KmRo65kTm77yqwSBNXa411WO3&index=7&ab_channel=Wolfgang%27sChannel

If you want to know how to set up your server on a Raspberry Pi, you should start by reading the blog post titled `Self-host your APIs (Series), Part 1`.

Also, by following along with this blog post, you agree you have read the disclaimer at the end.


## Update your Ubuntu packages and install new useful packages

Update Ubuntu package index and upgrade in one go without being prompted for confirmation

`sudo apt -y update && sudo apt upgrade`

- Add nmap package for network exploration and security auditing: https://nmap.org/

`sudo apt -y install nmap`

Now you can check all of your devices connected to your LAN with: `nmap -sP 192.168.1.255/24`

- Install git for version control: https://git-scm.com/download/linux

`sudo apt -y install git`

- Install the machine-learning-oriented package manager Miniconda from the official repository: https://repo.anaconda.com/miniconda/

First, create a new directory in `/home/` to place your downloaded packages

```
mkdir -p ~/Downloads/packages/ && cd ~/Downloads/packages/  
```

You would usually want to install the latest version `Miniconda3-latest-Linux-aarch64.sh`. However, in v4.10.0 and later there seems to come up an `Illegal instruction` installation error. This issue on Stack Overflow recommends using a the previous 4.9.2 version: https://stackoverflow.com/questions/68213186/illegal-instruction-error-when-verifying-anaconda-miniconda-install

```
wget https://repo.anaconda.com/miniconda/Miniconda3-py39_4.9.2-Linux-aarch64.sh # Download miniconda for Pi
sha256sum Miniconda3-py39_4.9.2-Linux-aarch64.sh  # Confirm that the package was downloaded correctly
sudo /bin/bash Miniconda3-py39_4.9.2-Linux-aarch64.sh  # Run the installer
```

Follow the instructions that appear on the screen. When prompted on where to install Miniconda3 input `/home/ubuntu/miniconda3`. Now you will need to add the `/home/ubuntu/miniconda3` path to your system's `~/.*rc` file. Do:

```
conda init bash
```

This will automatically add full functionality to the `conda` command in your system. For changes to take effect, close and re-open your current shell. You can do `source ~/.bashrc`.

To finish up, let's create a new environment using the latest available Python version

`conda create --name new-base python`

Now in `~/.profile` add the following line at the end:

```
conda activate new-base
```

And run the following command to create a `~/.condarc` file with an instruction to prevent from activating your base environment by default:

```
conda config --set auto_activate_base false
```

Now you should be able to reboot your Pi and have your brand new default environment activated for you every time.

***Note:*** If you run into `Illegal instruction` errors when running `conda` commands, this video recommends the following: https://www.youtube.com/watch?v=huXYSS_3034&ab_channel=NewmanSolutions

```
sudo cp /usr/lib/aarch64-linux-gnu/libcrypto.so.1.1 /home/ubuntu/miniconda3/lib/
```

I do not know why this works and I have not need to tried it myself, but I am documenting it here just in case. I also don't know if there are any drawbacks from copying `libcrypto.so.1.1` to my miniconda3 lib.

- For more information about Miniconda installations, you can go to: https://docs.conda.io/projects/conda/en/latest/user-guide/install/linux.html
- Manage conda environments: https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html


## Useful Linux commands

I was not a regular Linux user, so I am leaving these here for future reference.

```
# Useful commands

byobu  # https://www.byobu.org/documentation
shutdown now  # shut down your server
rmdir  # instead of rm -rf
whatis | info
which
sudo apt purge
sudo apt autoremove
!3  # execute command 3 in history
!-2  # Execute the command from two executions before
!! # retype previous command. Basically the same as UP arrow? You can edit it.
select-editor  # set editor for any future use for this user

# Config commands

sudo netplan apply  # https://linuxconfig.org/ubuntu-20-04-connect-to-wifi-from-command-line
systemctl # https://man7.org/linux/man-pages/man1/systemctl.1.html # https://www.digitalocean.com/community/tutorials/how-to-use-systemctl-to-manage-systemd-services-and-units

# System info

lsb_release -a && cat /etc/os-release # Display Ubuntu version
uname -a  # Get detailed information about your system
date  # Current server's date
lspci  # system specs
free -h  # Used RAM
du -h [dir]  # Size of dir and sub dirs
df -alh [dir]  # File system disk space usage. All local files, human readable.
df -alh | grep "/dev/mmcblk0p2"  # Display available usage of the partition with the root file system
ps  # Get list of all processes
top  # display linux processes
sudo ss -ltn  #check for open ports
nmap -sP 192.168.1.255/24 # List all devices in network
w  # Which users are logged into the server
uptime  # how long the system has been running in one line
who -u  # Find the process IDs of the current user sessions
kill "pid"  #  kill user session or any other process
journalctl -xe  # Query the systemd journal
pstree  # display a tree of processes
namei -om /path/to/check  # Display all the permissions on a path,

# Keyboard shortcuts

Ctrl + U    Clears the entire current line
Ctrl + K    Clears the command from the cursor right
Ctrl + W    Delete the word before the cursor
Ctrl + R    Allows you to search your history for commands matching what you have typed
Ctrl + Z    Suspend the current process by sending the signal SIGSTOP
Ctrl + L    Clears the terminal output
Alt + F Move forward one word
Alt + B Move backward one word
Ctrl + Shift + C    Copy the highlighted command to the clipboard
Ctrl + Shift + V or Shift + Insert  Paste the contents of the clipboard
Ctrl + Shift + T    Open new tab on current terminal
Ctrl + Shift + W    Close the current tab
```

## Set up handy aliases to navigate your server

1. If you haven't, then create a new file at `~/.bash_aliases`:

```
sudo nano ~/.bash_aliases
```

Then copy the following aliases. See the comments for functionality.


```bash
# Aliases for /home/ubuntu/.bash_aliases

# Handy commands

# edit aliases quickly
alias editaliases="sudo nano ~/.bash_aliases"
alias removealiases="rm ~/.bash_aliases"
alias implementaliases="source ~/.bashrc"

# reboot w sudo
alias reboot_server="sudo reboot"

# power down with sudo
alias off="sudo shutdown now"

# Source bashrc
alias reboot_bash='source ~/.bashrc'

# Clear your screen with `c` instead of Ctrl+L or `clear`
alias c="clear"

# Short 'history' version
alias h="history"

# Support for multiple terminals
alias b="byobu"

# Use '..' instead of 'cd ..' to go up in directory tree
alias ..="cd .."
alias ...="cd ../../../"
alias ....="cd ../../../../"
alias .3="cd ../../../../"
alias .4="cd ../../../../"
alias .5="cd ../../../../.."

# Navigate to previous directory
alias cdl="cd -"

# Enable color support
alias dir='dir --color=auto'
alias vdir='vdir --color=auto'
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'

# List files and directories better by default with "ls"
# -a list hidden files
# -l as vertical list
# -t show time of last modification 
# -c Sort by time of last modification
# -b escape non-graphic chars with C-style escapes
# -h human-readable file sizes
# -p add '/' to indicate directories
# -s print the size of each file
alias "lss"="ls -altcbhps --group-directories-first --color=auto"
# Same but without sorting
alias ls="ls -albhps --group-directories-first --color=auto"

# ls cheatsheet
# d  rwx  r-x  r-x
# ┬  ─┬─  ─┬─  ─┬─  
# │   │    │    │  
# │   │    │    └─ 4. Other｜5 (4+0+1)
# │   │    └────── 3. Group｜5 (4+0+1)
# │   └─────────── 2. User ｜7 (4+2+1)
# └─────────────── 1. File Type | directory

# Make nested directories by default with 'mkdir dir1/dir2/' structure
alias mkdir="mkdir -p"

# Unpack .tar file
alias untar="tar -zxvf "

# Update and upgrade in one command
alias aptup="sudo apt update && sudo apt upgrade"

# Display system memory usage in gigabytes
alias meminfo="free -g -l -t"

# Display the 15 processes using most gpu power
alias cpuinfo="ps auxf | sort -nr -k 3 | head -15"

# Create a 16-char long random password
alias mkpwd="openssl rand -base64 16"

# Check checksum
alias sha="shasum -a 256 "

# Stop pings at 5
alias ping="ping -c 5"

# Get external ip
alias ipe="curl ipinfo.io/ip"

# quicly find a command from grep history
alias gh="history|grep"

# Count files in this directory and subdirectories
alias countfr="find . -type f | wc -l"
alias countf.="find . -maxdepth 1 -type f | wc -l"

# Make mounted volumes readable
alias smount="mount | awk -F' ' '{ printf \"%s\t%s\n\",\$1,\$3; }' | column -t | egrep ^/dev/ | sort"

# Aesthetics

# Add color to diff command
alias diff="colordiff"


# Safety

# Say what rm is doing plus do not delete your root directory
alias rm="rm -v --preserve-root"

# Make sudo work with aliases
alias sudo="sudo "

# Verbose chmod. NEVER use 777.
alias chmod="chmod -c"
alias chmod_read_owner="chmod 400 "
alias chmod_full_owner="chmod 700 "
alias chmod_read_gp="chmod 440 "
alias chmod_full_gp="chmod 770 "
alias chmod_read_all="chmod 444 "

# Display all the permissions on a path,
alias path_check="namei -om " # + Path to check


# 400 r--------   Readable by owner only
# 500 r-x------   Avoid Changing
# 600 rw-------   Changeable by user
# 644 rw-r--r--   Read and change by user
# 660 rw-rw----   Changeable by user and group
# 700 rwx------   Only user has full access
# 755 rwxr-xr-x   Only changeable by user
# 775 rwxrwxr-x   Sharing mode for a group
# 777 rwxrwxrwx   Everybody can do everything


# Python

# Create virtual environment with name of parent directory and install pip tools and bpython
alias ve='python3 -m venv venv --prompt=$(pwd | egrep -o "([^s/]+)$") --clear && va && pip install pip-tools bpython'

# Activate virtual environment in this directory
alias va="source ./venv/bin/activate"

# Deactivate virtual environment (when active)
alias vd='deactivate'

# Remove this virtual environment
alias vr="rm -rf ./venv/"

# Compile and install requirements using pip-tools
alias pippin='pip-compile --upgrade requirements.in && pip install -r requirements.txt'


# Nginx

# Quickly do nginx stuff
alias nginxreload="sudo /usr/local/nginx/sbin/nginx -s reload"
alias nginxtest="sudo /usr/local/nginx/sbin/nginx -t"


## Marks

alias cdd='jump'
export MARKPATH=$HOME/.marks
function jump { 
    cd -P "$MARKPATH/$1" 2>/dev/null || echo "No such mark: $1"
}
function mark { 
    mkdir -p "$MARKPATH"; ln -s "$(pwd)" "$MARKPATH/$1"
}
function unmark { 
    rm -i "$MARKPATH/$1"
}
function marks {
    \ls -Al "$MARKPATH" | tail -n +2 | sed 's/  / /g' | cut -d' ' -f9- | awk -F ' -> ' '{printf "%-10s -> %s\n", $1, $2}'
}

```


## Set custom key bindings

I haven't done this but I might in the future. This guide should get you started: https://techwiser.com/custom-keyboard-shortcuts-ubuntu/


## Choose your server's local time

1. Run the `date` command to find the day and time your server is on.
2. You can also run `cat /etc/localtime` to peek at the time zone information.
3. Run `tzselect` and choose your desired time zone for your server.
4. Follow the instructions and update the time zone with `TZ`
5. Reboot your Pi: `sudo reboot`
6. Make sure the changes have taken effect with `cat /etc/localtime`


## Change your Ubuntu server host name

You might be connecting to your server via `ssh user@internal-ip`, but you can also connect via `ssh user@hostname`. For this you might want to change to a host name to something unique that can be found in your network. To learn more about why you'd want to do this you can go to: https://www.ionos.com/digitalguide/hosting/technical-matters/hostname/.

You can find your server's hostname by running the command `hostname` in an Ubuntu terminal. The default host name for Ubuntu Server LTE 20.04 is `ubuntu`.  To change it, you can do:

```
sudo hostname firecracker  # Now your server's hostname is `firecracker`
```

edit your host name in this file: 

```
sudo nano /etc/hostname
```

Now, delete any lines where your old host name appears in `/etc/hosts`. First look at it with `cat /etc/hosts`. Then, if your old host name appears, you can change it via `sudo nano /etc/hosts`. You might also want to add your new local host name so that the file starts with:

```
127.0.0.1    localhost
127.0.1.1    firecracker
```

Or you have a domain name you can do both separated by a space 

```
127.0.0.1    localhost
127.0.1.1    firecracker@your-domain-name.com firecracker
```

Now you can ping either name inside your Pi or from your local computer:

`ping firecracker`

You might also want to change your host name in your local `~/.ssh/config` file:

```
Host pi
  HostName firecracker
  User ubuntu
  IdentityFile ~/.ssh/id_ed25519-firecracker
```

You can also change your host name using the `hostnamectl` command. Check this guide out: https://www.cyberciti.biz/faq/linux-change-hostname/

Other resources: https://www.youtube.com/watch?v=91dNq4C6260&ab_channel=LearnLinuxTV


## Change your Ubuntu server passwords

To change your *user* password, you can do:

```
sudo passwd
```

To change your *root* password, you can do:

```
sudo passwd root
```

More resources:

- https://linuxways.net/ubuntu/how-to-change-the-root-password-of-ubuntu-20-04/
- https://linuxhint.com/change_password_ubuntu/


## Connect to Ubuntu Server via SSH with password authentication

You probably already set this up if you come from the `Self-host your APIs (Series), Part 1` blog post. If not, I will just copy the contents here:

First, you will need to find the Pi’s IP address. If you are working on the Pi terminal, you can do this by running:

```
ip address
```

Your modem will assign a temporary IP address to your Pi, which we need to find out if we're going to communicate to your Pi in any way inside your local network. Depending on how your Pi is connected to your local network, you need to look for the following:

- `2: eth0`: your Ethernet connection
- `3: wlan0`: which corresponds to your local wireless

Regardless of which way your Pi is connected to the internet, you will want to find the line containing `brd`, followed by a space and a local host address. In my case it looked like this:

```
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether dc:a6:32:c4:29:a4 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.86/24 brd 192.168.1.255 scope global dynamic eth0
```

In the example above, my temporary IP address was `192.168.1.86`. To make your search easier you can find the lines with ` brb ` using a regular expression like so: `ip address | grep " brd "`

If you were working on your regular (local) computer and wanted to find your Pi's address, you could open the command line and, assuming that your computer is connected to the same local network as the Pi, you could run:

```
dig ubuntu  # Replace `ubuntu` by your Pi's hostname if needed. The default is "ubuntu"
```

You can find your server's hostname by running the command `hostname` in an Ubuntu terminal. You might need to do this again if you need to SSH a second time because by default IP addresses are dynamic in Ubuntu. You can set up a static IP address via your modem/router or by changing the network configuration of your Ubuntu server. Learn more at: https://linuxconfig.org/how-to-configure-static-ip-address-on-ubuntu-20-04-focal-fossa-desktop-server

Now we can use this address to connect to your Pi remotely using `ssh` or `putty`. 

Before connecting from your regular (local) computer, you will need to go to your Pi's terminal and install the OpenSSH server package manually. Make sure to run `sudo apt update` to make sure your sever packages are up-to-date and then upgrade any outdated packages with `sudo apt upgrade`. `apt` helps you interact with Ubuntu's Advanced Packaging Tool (APT). You can learn more at:https://ubuntu.com/server/docs/package-management#:~:text=Apt,upgrading%20the%20entire%20Ubuntu%20system.


```
sudo apt update  # Update your server's package index
sudo apt upgrade  # Upgrade outdated packages in your server
sudo apt install openssh-server  # Install OpenSSH server package
```

Now you need to enable SSH

```
sudo service ssh enable
sudo service ssh start
```

Now, go to your usual computer and connect via ssh like so:

```
ssh ubuntu@192.168.1.86
```

You will be asked to input your password and then you will be able to work as if you were logged inside the Pi.

For added security, you can connect by creating a SSH public/private key pair. To learn more you can visit: https://phoenixnap.com/kb/ssh-with-key

For more on network configuration, go to the Ubuntu documentation directly https://ubuntu.com/server/docs/network-configuration


## Configure a static IP address

By default, Ubuntu's IP addresses are dynamic, which means they will change regularly. In many cases, this configuration can be changed from your modem/router. You need to google how to do this for your specific modem/router model or internet service provider (ISP). However if you want to change it from inside your server, you can tinker with the DHCP configuration directly.

1. Edit your netplan configuration file `sudo nano /etc/netplan/50-cloud-init.yaml`
2. Apply your settings with `sudo netplan apply` or `sudo netplan --debug apply`

Assuming you are using Ethernet as your connection (`eth0`), and you want your static-ip to be `192.168.1.86`, your `50-cloud-init.yaml` file should end up looking like this:

```
# This file is generated from information provided by the datasource.  Changes
# to it will not persist across an instance reboot.  To disable cloud-init's
# network configuration capabilities, write a file
# /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:
# network: {config: disabled}
network:
    ethernets:
        eth0:
            dhcp4: true
            optional: true
            addresses: [192.168.1.86/24]
            gateway4: 192.168.1.1
            nameservers:
              addresses: [8.8.8.8,8.8.4.4,192.168.1.1]
    version: 2
```


https://linuxconfig.org/how-to-configure-static-ip-address-on-ubuntu-20-04-focal-fossa-desktop-server


## Set up VScode for remote development using SSH password authentication

While there are many reasons why you might want to use VScode to connect from your local computer to your Pi, for me they boil down to two: I am used to working on VScode and I have it customized just the way I like, and some extensions do make my life better without leaving VScode, like the MongoDB extension. The VScode official documentation has more reasons why setting VScode for remote development might be a good option: https://code.visualstudio.com/docs/remote/remote-overview

First, let's try to connect via password authentication. In a later section we'll later set it up to use a public key, and finally a public key and a password.

Be mindful that you cannot use remote VSCode on all not all operating systems. Ubuntu 20.04 does. To learn more you can read: https://code.visualstudio.com/docs/remote/ssh#_getting-started

1. Get [VScode](https://code.visualstudio.com/) for your normal computer.
2. Open VScode, look for the Extension marketplace and install the `Remote Development` extension pack (https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack)
3. In your Pi, install OpenSSH server if you haven't `sudo apt install openssh-server`

You should be ready to connect via SSH with your password. To connect:

1. Click on the green button at the bottom-left corner of VScode that should appear after you have installed the remote development extension pack.
2. Click on the `Connect to Host` option that will appear at the top of the screen
3. Clcick on `+Add New SSH Host`
4. Input the command to connect to your Pi as you normally would. In my case: `ssh ubuntu@192.168.1.86`. Notice that if your local IP address is not permanent, you will have to re-set it again later. To find your Pi's IP address, you can do `dig ubuntu` from your normal computer, or `hostname -i` from your Pi.
5. From the drop-down list, select `Users/YourComputer/.ssh/config`. VScode will save the configuration for connecting to your Pi in this configuration file.
6. Click on the green button again and then click on `Connect to Host`. You will see the IP address for your Pi. Select it and you're in!
7. Alternatively, you can connect to your Pi from the terminal `code --remote ssh-remote+remote_server /full/path/to/your/code/`. In my case, this would be `code --remote ssh-remote+ubuntu@firecracker /home/ubuntu/pydev/test_api/`

Now add extensions via the Extensions menu. Once you've clicked on the Extensions menu icon, locate the drop down menu on the left that starts with `[SSH Your-IP-Address]`, click on the cloud button and you will be able to select which of your locally installed extensions you want to install in your Pi. Click accept. Once the download is done, you will be able to code from VS code!

Other resources:

- Remote development over SSH: https://code.visualstudio.com/docs/remote/ssh-tutorial
- Remote Development Tips and Tricks: https://code.visualstudio.com/docs/remote/troubleshooting
- https://www.youtube.com/watch?v=QW70p8lLE4A&list=WL&index=1
- https://www.youtube.com/watch?v=rh1Ag41J6IA&list=WL&index=2&ab_channel=VisualStudioCode


## Use VScode for remote development via SSH key authentication

First, create a key pair in your local (normal) computer:

1. Create an `~/.ssh` directory if you don't already have it.
2. Make sure you are the only one who has permissions for this directory `chmod 700 ~/.ssh`
3. Check your existent keys in your local computer with `ls -l ~/.ssh/id*`
4. Install `ssh-keygen` for your system  https://code.visualstudio.com/docs/remote/troubleshooting#_improving-your-security-with-a-dedicated-key
5. Generate an SSH key pair in your usual computer using `ssh-keygen -t ed25519 -f ~/.ssh/id_ed25519-firecracker`. This will create a key pair from the type `ed25519` called `id_ed25519-firecracker.pub` and `id_ed25519-firecracker` in your `~/.ssh/` directory. 
6. You will be asked for a passphrase. You can leave it empty for now. Later, we'll see how to work with a key and a passphrase.
7. Make sure that your public file is readable and writable only by your on your local machine. Do: `chmod 600 ~/.ssh/id_ed25519-firecracker.pub`
8. To prevent any errors from logging in using `ssh` password, in your local computer, clean up the `~/.ssh/known_hosts` file manually from any connection to your Pi, or by running `ssh-keygen -R hostname`, which in my case it would be `ssh-keygen -R firecracker`

Second, add the ***public*** key to your Pi:

1. Now, use the command `ssh-copy-id -i /your/public/path/key.pub user@hostname` to copy your local public key to your Pi. Make sure you're copying the `.pub` file. Here is how it would look like for me: `ssh-copy-id -i ~/.ssh/id_ed25519-firecracker.pub ubuntu@firecracker`
2. Log in to your Pi and check that your key is in `cat ~/.ssh/authorized_keys` and that it matches your `id_ed25519-firecracker.pub` key in your local machine.
3. Make sure that your public file is readable and writable only by your on your local machine. Do: `chmod 700 ~/.ssh/authorized_keys`

You can now connect to your Pi without needing a password by specifying the path to your private key like so:

```
ssh ubuntu@firecracker -i .ssh/id_ed25519-firecracker
```

After this, you should be able to just ssh without needing to specify the key file path, as in `ssh ubuntu@firecracker`, since this will be stored in your configuration.

You should also be able to log in with VScode as you did before but now you should not need to input your password.

You might also want to simply connect by running `ssh pi` any time in your console. To do this, change your `~/.ssh/config` file to something like this:

```
Host pi
  HostName 192.168.1.86
  User ubuntu
  IdentityFile ~/.ssh/id_ed25519-firecracker
```

There are other cool configurations you can play with. Here are couple of good guides to learn about your SSH config file:

- https://linuxize.com/post/using-the-ssh-config-file/
- https://linuxhint.com/ssh-config-file/


## Strengthen your security with sshd_config

It is recommended that before you open your Pi to the public web, you turn off the ssh password login configuration in your Pi's from changing this:

```
#PasswordAuthentication yes
#PermitEmptyPasswords no
```

to this:

```
PasswordAuthentication no
PermitEmptyPasswords no
```

In order to change the configuration file, you'll have to use sudo: `sudo nano /etc/ssh/sshd_config`. Notice that ***if you don't have a key set up already you will be unable to ssh to your Pi*** (or whatever remote you reconfigured) and you will only be able to change it if you connect to the machine physically. Find more information here: https://www.cyberciti.biz/faq/how-to-disable-ssh-password-login-on-linux/

The next bit follows Wolfgang's Channel video "Selfhosting EP2: Setting up the system" https://youtu.be/rwv4La_UZDM?t=434. First, change the default port for ssh to something else. Again, in `/etc/ssh/sshd_config` make the following change:

```
#Port 22  # Change this to:
Port 69  # Or whatever port you want
```

You will also want to disallow root log in:

```
#PermitRootLogin prohibit-password  # Change this
PermitRootLogin no  # To this
```

Now restart the sshd daemon with `sudo systemctl restart sshd` and log out. Next time you log in you will have to specify the port via:

```
ssh pi -p 69
```

Now in your main computer change your `~/.ssh/config` file from this:

```
Host pi
  HostName firecracker
  User ubuntu
  IdentityFile ~/.ssh/id_ed25519-firecracker
```

To this:

```
Host pi
  HostName firecracker
  User ubuntu
  Port 69
  IdentityFile ~/.ssh/id_ed25519-firecracker
```

And you will be able to log into your Pi via `ssh pi` as before.

I believe logging in as root in Ubuntu is disabled by default, but you can do this anyway by running: 

```
sudo passwd -l root  # You will be prompted for your password
```

Other resources:

- https://www.tomshardware.com/how-to/host-public-website-raspberry-pi
- https://code.visualstudio.com/docs/remote/troubleshooting#_quick-start-using-ssh-keys
- https://code.visualstudio.com/docs/remote/ssh-tutorial
- https://code.visualstudio.com/docs/remote/troubleshooting


## Automate backups

Backing up your Pi is crucial to avoid data loss and wasting time if (or rather... "when") your MicroSD fails. In this section I will follow this YouTube tutorial and add automation to have a daily backup (though you might want to do backup more often):https://www.youtube.com/watch?v=KTayZIou-1M&ab_channel=OddRandomThoughts 

We'll set up a very simple compressed backup (using `tar`) without downloading any additional packages (at least you should not need to). First, let's have a look at the basic backup command that we'll use. We'll modify it later for automation:

```
sudo tar -cvpzf /bkp.tar.gz --exclude=/bkp.tar.gz --one-file-system /

# /bkp.tar.gz: The path and name of your new backup (in root for now). Make sure to include `.tar.gz`
# -c: create new archive
# -v: verbose mode
# -p: preserve file permissions
# -z: use gzip to compress your archive
# -f: indicate file name and location for archive
# --exclude=bkp.tar.gz: Do not put a copy of backp.tar.gz inside /backp.tar.gz
# --one-file-system: Stay in local file system when creating archive (exclude dirs like mnt/, media/, etc)
# /: the directory you want to back up. In this case, we backup the root dir.
```

If you run the above command, the `bkp.tar.gz` file will be created in your Pi's MicroSD card. This is ok if you want to restore your root directory later to a certain moment in time. However, you most likely want to have a security backup on an external device. So get yourself an USB flash drive with enough memory to backup all of your Pi files . Make sure to format it using exFAT so that you can backup large files in Linux. See the resources list at the end of this section for links on how to format flash drives on Mac, Linux, and Windows.

Now before you insert your flash drive into your Pi, type `lsblk` (easy to remember: "ls block(devices)") on your Pi console to list all the devices mounted on your Pi. Take note of all the existing ones, for example mine are:

```
NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS
loop0         7:0    0  57.9M  1 loop /snap/core20/1614
loop1         7:1    0    59M  1 loop /snap/core20/1627
loop2         7:2    0  60.7M  1 loop /snap/lxd/21843
loop3         7:3    0    61M  1 loop /snap/lxd/22761
loop4         7:4    0  41.5M  1 loop /snap/snapd/17032
loop6         7:6    0  41.5M  1 loop /snap/snapd/16782
mmcblk0     179:0    0 119.3G  0 disk 
├─mmcblk0p1 179:1    0   256M  0 part /boot/firmware
└─mmcblk0p2 179:2    0   119G  0 part /
```

After you have noted this information, insert your flash drive and note what lines have changed.

```
NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS
loop0         7:0    0  57.9M  1 loop /snap/core20/1614
loop1         7:1    0    59M  1 loop /snap/core20/1627
loop2         7:2    0  60.7M  1 loop /snap/lxd/21843
loop3         7:3    0    61M  1 loop /snap/lxd/22761
loop4         7:4    0  41.5M  1 loop /snap/snapd/17032
loop6         7:6    0  41.5M  1 loop /snap/snapd/16782
sda           8:0    1  14.6G  0 disk 
└─sda1        8:1    1  14.6G  0 part 
mmcblk0     179:0    0 119.3G  0 disk 
├─mmcblk0p1 179:1    0   256M  0 part /boot/firmware
└─mmcblk0p2 179:2    0   119G  0 part /
```

Note: You can also use the `sudo fdisk -l` or the `sudo blkid` command to list the devices and partitions in your system.

In my case, I can now see two new lines for my flash drive: `sda` and `sda1`. These block devices can be found under `ls /dev/sda*`. We'll use this information to create a mountpoint. For what I understand, this is not necessary in Linux, but it is desirable if you want your flash drive directory to not change, that is if you want your device to always be mounted under a certain path, which we do in order to automate those backups.

First, let's create a new directory called `backup_usb` inside `/mnt`:

`sudo mkdir /mnt/bkp_usb`

Now get that info that you gathered before (in my case, I'll use the `sda1` partition in my flash drive) and we'll mount the flash drive to make it available in my new directory:

`sudo mount /dev/sda1 /mnt/bkp_usb`

You can verify that your flash drive is mounted by using the `df` command:

```
df -h
# Filesystem      Size  Used Avail Use% Mounted on
# tmpfs           781M  3.1M  778M   1% /run
# /dev/mmcblk0p2  118G  7.0G  106G   7% /
# tmpfs           3.9G   96K  3.9G   1% /dev/shm
# tmpfs           5.0M     0  5.0M   0% /run/lock
# /dev/mmcblk0p1  253M  125M  128M  50% /boot/firmware
# tmpfs           781M  4.0K  781M   1% /run/user/1000
# /dev/sda1        15G  3.0M   15G   1% /mnt/bkp_usb <-- Here is your backup drive
```

Note: If mount fails, you can reboot your system and try again. If at any point you want to eject your flash drive, use `sudo umount /dev/sda1`

Let's test your flash drive backup by running:

```
ls /mnt/bkp_usb/bkp$(date "+%Y%m%d").tar.gz || sudo tar -cvpzf /mnt/bkp_usb/bkp$(date "+%Y%m%d").tar.gz --one-file-system /

# /mnt/bkp_usb/: flash drive mount path
# ls /mnt/bkp_usb/bkp$(date "+\%Y\%m\%d").tar.gz: check if backup with current date exists
# $(date "+%Y%m%d"): Today's date using the yyyymmdd format
# ||: OR operator (if the ls command fails, i.e. if bkp file does not exist)
# tar -cvpzf /mnt/bkp_usb/bkp$(date "+%Y%m%d").tar.gz --one-file-system /: backup in path
```

You can also remove previous backups in your flash drive with something like `rm "$(ls -t /mnt/bkp_usb/ | tail -1)"`. We'll also schedule a cron job for this below just to avoid filling up the flash drive to the point that you cannot backup any more. Try running this from your command line:

```
sudo rm /mnt/bkp_usb/$(ls -t /mnt/bkp_usb/ | tail -1 | grep -o bkp.*)
# rm: delete file
# /mnt/bkp_usb/: prefix of the file we're going to delete
# ls -t /mnt/bkp_usb/: list files in path, sorted by time
# | tail -1: pipe list from ls and get the last item (oldest)
# grep -o bkp.*: get only the name of the file (starts with bkp)
# $(ls -t /mnt/bkp_usb/ | tail -1 | grep -o bkp.*): put output at the end of the rm path
```

Now let's automate this backup using our `/etc/crontab` file. `cron` is a daemon that allows you to run commands at a specified  time intervals and `crontab` is a utility that helps you manage `cron` jobs for individual users. If you're running Ubuntu Server 20.04, you should have `cron` in your system. You can check by running `dpkg -l cron`.  Otherwise, get it with `sudo apt install cron`. This should create a `ls /etc/crontab` dir in your system and you should be able to run `crontab` commands.

Check if cron is running in your machine. Run `sudo systemctl status cron`. If cron is not running you can either use the `sudo systemctl start cron` or `sudo systemctl restart cron` commands.

Before we start messing with cron, here is the basic knowledge that we'll need. Cron will run the commands that you put inside the special file `/etc/crontab` (which you should ***not*** edit directly, see below) and it will run them as your user, so some of them will need sudo. You will also need to escape percent signs with backslashes which in cron mean newline characters.

In the crontab file, you can specify time intervals using numbers and operators in the first five arguments before the command you want to run. Here is the gist (you can always copy and paste the information below on your crontab file and escape each line with #)

```
Interval:  * Every unit (minute, hour, etc)
Interval:  */10 every 10 units
List:      0,5 first and sixth unit
Range:     0-5 from the first to the sixth unit

┌───────────── minute (0 - 59)
│ ┌───────────── hour (0 - 23)
│ │ ┌───────────── day of month (1 - 31)
│ │ │ ┌───────────── month (1 - 12)
│ │ │ │ ┌───────────── day of week (0 - 6) (Sunday to Saturday)
│ │ │ │ │
│ │ │ │ │
│ │ │ │ │
* * * * * command_to_execute
```

Let's say we want to back up every day ten minutes after midnight. You will need to use the following notation:

```
10 0 * * * YOUR_COMMAND_HERE
# at minute 10
# every 0 hour (midnight)
# of every calendar day of the month
# of every month
# of every day
```

If you want to modify your cron interval, you can use this useful online tool to get the correct combination: https://crontab.guru/

Now let's edit your user crontab file with `crontab -e`. Your editor will open. Now you can copy the following information:

```
# SYS BACKUP

# Back up at five minutes past midnight
5 0 * * * sudo ls /mnt/bkp_usb/bkp$(date "+\%Y\%m\%d").tar.gz || sudo tar -cpzf /mnt/bkp_usb/bkp$(date "+\%Y\%m\%d").tar.gz --one-file-system /
# 5 0 * * *: Execute the following command at five minutes past the zero hour (midnight)
# /mnt/bkp_usb/: flash drivee mount path
# $(date "+\%Y\%m\%d"): Today's date using the yyyymmdd format. Notice you need escape chars `\`
# ls mnt/bkp_usb/bkp$(date "+\%Y\%m\%d").tar.gz: check if backup with current date exists
# ||: OR operator (if the ls command fails, i.e. if bkp file does not exist, do the following)
# tar -cpzf /mnt/bkp_usb//bkp$(date "+\%Y\%m\%d").tar.gz --one-file-system /: no need for verbose

# Empty oldest backup every day at ten past midnight
10 0 * * * sudo rm /mnt/bkp_usb/$(ls -t /mnt/bkp_usb/ | tail -1 | grep -o bkp.*)

# Attempt backup up again at noon just in case the midnight backup failed
0 12 * * * sudo ls /mnt/bkp_usb/bkp$(date "+\%Y\%m\%d").tar.gz || sudo tar -cpzf /mnt/bkp_usb/bkp$(date "+\%Y\%m\%d").tar.gz --one-file-system /
```

If you save the file correctly, you will see the output "crontab: installing new crontab". This means that you don't need to run `systemctl restart cron`. You can find additional messages if you run `systemctl status cron`. Now you can wait for your backup to happen during the interval that you specified. You should have at least one backup at any given time after the first backup schedule runs. Be aware that cron runs commands according to your server's date and time. To find out what is your server's date and time, use the `datetime` command.

You can verify the contents of your backup by first getting the name of the file with `ls /mnt/bkp_usb/`, then looking at your most recent backup and doing:

```
tar -tf /mnt/bkp_usb/bkp20221006.tar.gz
# Change the date for the latest backup in your flash drive.
```

You might also want to create aliases in your `~/.bash_aliases` file to create and delete back ups manually:

```
alias mount_bkp='sudo mount /dev/sda1 /mnt/bkp_usb'
alias unmount_bkp='sudo umount /dev/sda1'
alias create_bkp='sudo ls /mnt/bkp_usb/bkp$(date "+%Y%m%d").tar.gz || sudo tar -cvpzf /mnt/bkp_usb/bkp$(date "+%Y%m%d").tar.gz --exclude=//mnt/bkp_usb/bkp.* --one-file-system /'
alias remove_oldest_bkp='sudo rm /mnt/bkp_usb/$(ls -t /mnt/bkp_usb/ | tail -1 | grep -o bkp.*)'
```


# SYSTEM BACKUP



sudo su
crontab -e

sudo cat var/spool/cron/crontabs/ubuntu


Now let's restore our system with our backup.

Warning! This command will overwrite what you have in your root directory (that is why it works), so make sure that you really want to go back to that previous state or that you are working on a clean installation of the same system that you previously backed up.


```
sudo tar -xvpzf /mnt/bkp_usb/bkp(DATE_HERE).tar.gz -C: / --numeric-owner

# x: extract (instead of c)
# vpzf: same as before
# /mnt/bkp_usb/bkp(DATE_HERE).tar.gz: path and name of where your backup is located
# (DATE_HERE): change for the date of the backup to use. For example: bkp20220921.tar.gz
# -C: set destination of extraction directory
# /: Destination path (in this case, root)
# --numeric-owner: use numbers for user/group names (do not match owners from flashdrive)
```

After the process is done, reboot your Pi and you're done.

Resources:

- When do MicroSD cards fail? https://www.colesclassroom.com/how-long-do-micro-sd-cards-last/#:~:text=According%20to%20HowStuffWorks%2C%20memory%20cells,cards%20are%20generally%20long%2Dlasting
- More on mmcblk partitions on the Raspberry Pi: https://forums.raspberrypi.com/viewtopic.php?t=140856
- Format flash drives on Mac: https://support.apple.com/guide/disk-utility/format-a-disk-for-windows-computers-dskutl1010/mac
- Format flash drives on Linux: https://appuals.com/how-to-format-a-drive-as-exfat-on-linux/
- Format flash drives and create backups on Ubuntu server using `timeshift`: https://www.youtube.com/watch?v=ATDzlHOrZ_s&list=PLKONas2auXwYp4eMaLlai9KhVwW6V2OYs&index=37&t=73s&ab_channel=linux-syr
- Other backup options for your Ubuntu system: https://help.ubuntu.com/community/BackupYourSystem
- 3-2-1 Backup Rule: https://www.cisa.gov/uscert/sites/default/files/publications/data_backup_options.pdf
- What is the correct way to edit a crontab file? https://askubuntu.com/questions/609850/what-is-the-correct-way-to-edit-a-crontab-file



# Self-host your APIs (Series), Part 1: Setting up a basic API in a developer server with Ubuntu Server 20.04, Raspberry Pi, and Python's FastAPI

Before you start, read my disclaimer at the end of this blog post.

## Prerequisites

- I will assume that you want to use Ubuntu Server 20.04, which does not come with a Graphical User Interface. If you are unsure, please read more about it for example in: https://www.techrepublic.com/article/ubuntu-server-the-smart-persons-guide
- I will assume that you can find your way navigating around a Linux command-line system and in general that you are aquainted with the minimum command line knowledge covered in: https://ubuntu.com/tutorials/command-line-for-beginners
- You know what a Raspberry Pi is and you have one at your disposal to get your hands dirty: https://projects.raspberrypi.org/en
- You know how to program in Python and you are interested in getting started (along with me) on web design.
 

## Install Ubuntu Server 20.04 LTS for Raspberry Pi

Raspberry Pis don't usually come with an operating system installed. You need to add it either via a USB or a MicorSD card. I recommend you have an empty MicroSD card with at leas 16 GB storage and plug it into your computer (you may need an adapter). 

In your regular (local) computer, download and install the `Raspberry Pi imager` software from the official website: https://www.raspberrypi.com/software/

Open the `Raspberry Pi imager`. Click on the "CHOOSE OS" button and pick the “Other general-purpose OS” option. Assuming you've bought a Raspberry Pi 4B, find "Ubuntu" and pick the "Ubuntu Server 20.04 LTS 64-bit" version OS for arm64 architectures, then click on "WRITE". If you are unsure of which operating system to install, you can use this guideline: https://ubuntu.com/download/raspberry-pi

For a step-by-step guide with images you can follow the first part of the following blog post: https://linuxhint.com/install-ubuntu-server-raspberry-pi/


## Boot up your Raspberry Pi and connect it to the internet

Connect your Raspberry Pi to a power outlet, a keyboard and a monitor. If you have an Ethernet connection available, you can do that too either now or at any point. Go ahead and insert the SD card once Pi requests that you do so (you will see it on the screen). For more on how to set-up your Pi hardware, you can check out this blog post from the Raspberry Pi Foundation: https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up/1

Login to your server using the default user name "ubuntu" and default user password, which is "ubuntu", as well. Follow the instructions. You will be prompted to change the password the first time you use it. You can always change it later following this blog post: https://linuxhint.com/change-password-ubuntu-22-04/

Connect to the internet:
https://linuxconfig.org/ubuntu-20-04-connect-to-wifi-from-command-line

```
ls /etc/netplan/
```

You should see a file with a .yaml extension. That is your configuration file. Mine is `50-cloud-init.yaml`. Now edit the file 
sudoedit /etc/netplan/50-cloud-init.yaml

sudo netplan apply


## Connect to your Ubuntu server from another computer in your network

First, you will need to find the Pi’s IP address. If you are working on the Pi terminal, you can do this by running:

```
ip address
```

Your modem will assign a temporary IP address to your Pi, which we need to find out if we're going to communicate to your Pi in any way inside your local network. Depending on how your Pi is connected to your local network, you need to look for the following:

- `2: eth0`: your Ethernet connection
- `3: wlan0`: which corresponds to your local wireless

Regardless of which way your Pi is connected to the internet, you will want to find the line containing `brd`, followed by a space and a local host address. In my case it looked like this:

```
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether dc:a6:32:c4:29:a4 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.86/24 brd 192.168.1.255 scope global dynamic eth0
```

In the example above, my temporary IP address was `192.168.1.86`. To make your search easier you can find the lines with ` brb ` using a regular expression like so: `ip address | grep " brd "`

If you were working on your regular (local) computer and wanted to find your Pi's address, you could open the command line and, assuming that your computer is connected to the same local network as the Pi, you could run:

```
dig ubuntu  # Replace `ubuntu` by your Pi's hostname if needed. The default is "ubuntu"
```

You can find your server's hostname by running the command `hostname` in an Ubuntu terminal. You might need to do this again if you need to SSH a second time because by default IP addresses are dynamic in Ubuntu. You can set up a static IP address via your modem/router or by changing the network configuration of your Ubuntu server. Learn more at: https://linuxconfig.org/how-to-configure-static-ip-address-on-ubuntu-20-04-focal-fossa-desktop-server

Now we can use this address to connect to your Pi remotely using `ssh` or `putty`. 

Before connecting from your regular (local) computer, you will need to go to your Pi's terminal and install the OpenSSH server package manually. Make sure to run `sudo apt update` to make sure your sever packages are up-to-date and then upgrade any outdated packages with `sudo apt upgrade`. `apt` helps you interact with Ubuntu's Advanced Packaging Tool (APT). You can learn more at:https://ubuntu.com/server/docs/package-management#:~:text=Apt,upgrading%20the%20entire%20Ubuntu%20system.


```
sudo apt update  # Update your server's package index
sudo apt upgrade  # Upgrade outdated packages in your server
sudo apt install openssh-server  # Install OpenSSH server package
```

Now you need to enable SSH

```
sudo service ssh enable
sudo service ssh start
```

Now, go to your usual computer and connect via ssh like so:

```
ssh ubuntu@192.168.1.86
```

You will be asked to input your password and then you will be able to work as if you were logged inside the Pi.

For added security, you can connect by creating a SSH public/private key pair. To learn more you can visit: https://phoenixnap.com/kb/ssh-with-key

For more on network configuration, go to the Ubuntu documentation directly https://ubuntu.com/server/docs/network-configuration


## Setting Up Python 3 and pip3

We will make sure that we have Python 3 installed 

```
sudo apt update  # Update your server's package index
sudo apt -y upgrade  # You can add the -y flag to omit saying 'yes'
sudo apt Python3
```
To look at your Python version, do:

```
python3 -V
```

Install `pip` to manage dependencies and `venv` to manage virtual environments

```
sudo apt install -y python3-pip
sudo apt install -y python3-venv
```

## Set up your project structure

We'll use the following directory structure:

```
.
└── pydev
    └── test_api  # You can put stuff here like .git, .gitignore and venv 
        └── my_app  # Your API app. Retain this directory name
            └── __init__.py  # Turns your `my_app` into a Python package
```

Let's create our root directory for web development projects with Python. We'll call it `pydev`. We'll also create a root directory for this particular project, called `test_api`. Then, we'll create one called `my_app` for our Python API which will be turned into a package when we add an empty Python file called `__init__.py`. You can change the names of `pydev` or `test_api` directory to whatever you want, but let's keep the name `my_app` for now. You can do:

```
mkdir -p pydev/test_api/my_app && cd pydev/test_api
touch my_app/__init__.py
```

Later, we will be running `my_app.main:app` with uvicorn, but for this you will need: (a) a directory called `my_app`, (b) a Python script called `main.py` with our FastAPI code, and (c), an instance of the FastAPI class stored in the variable `app`. We'll repeat this information later when we look at the code.


## Set up your environment

Create a virtual environment (`python3 -m venv`) in a local directory (`python3 -m venv venv`) that shows a command prompt called "basic_api" when activated, based on yous system Python distribution. Learn more at: https://realpython.com/python-virtual-environments-a-primer/

```
deactivate  # in case you're already inside a virtual environment
python3 -m venv venv --prompt="basic_api --clear
source venv/bin/activate  # Activate the new virtual environment
```

Run the following command to look at the packages

```
python3 -m pip list
```

You should see at least two packages including `pip` and `setuptools`.

Now, unstall the dependencies we need for this project

```shell
pip install pip-tools
printf "fastapi\nuvicorn[standard]\nrequests" > requirements.in 
pip-compile --upgrade requirements.in  # Will create a requirements.txt file
pip install -r requirements.txt
```

The `[standard]` option for uvicorn installs useful additional dependencies like uvloop for concurrency. You can learn more at the uvicorn website: https://www.uvicorn.org/

Instead of using venv, you could install Anaconda, or Miniconda (to save some space) as shown in here: https://askubuntu.com/questions/1240489/how-can-i-download-and-install-miniconda


## Create a simple API

We'll create a very simple API using FastAPI and uvicorn, which you have installed above using `pip-compile`. The API will take in a user name, wait for five seconds and return the user name inverted.

https://realpython.com/fastapi-python-web-apis/

```Python
import time

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

@app.get("/")
async def root():
    return {"message": "Hello World"}

```

## Make it available as a dev-server with Raspberry Pi

```
uvicorn my_app.main:app --host 0.0.0.0 --port 8000
```

If you are using gunicorn:

```
gunicorn my_app.main:app --workers 4 --worker-class uvicorn.workers.UvicornWorker --bind 0.0.0.0:8000
```

If you run into the following error:

```
ERROR:    [Errno 13] error while attempting to bind on address ('127.0.0.1', 80): permission denied
```

https://github.com/KuroLabs/Airshare/issues/20

You should be able to see it inside your network using your Pi's local temporary IP address and your port (`ip:port`) . In my case, I could open a window browser in my regular (local) computer and type:

```192.168.1.86:8000```

Which would open the uvicorn server run by my Pi inside my local network.

To learn more about serving your API manually, the FastAPI documentation is a great resource: https://fastapi.tiangolo.com/deployment/manually/


## Resources:

Random APIs
https://www.programmableweb.com/category/random/api

Fetch the weather
https://projects.raspberrypi.org/en/projects/fetching-the-weather/3









# Securely deploy an NLP model

You may want to validate that the authorized_key file in the .ssh folder for your remote user on the SSH host is owned by you and no other user has permission to access it. See the OpenSSH wiki for details.
https://github.com/PowerShell/Win32-OpenSSH/wiki/Security-protection-of-various-files-in-Win32-OpenSSH#authorized_keys

Set up SSL certificate with Certbot and update Dynamic DNS from server:

Set up a free dynamic hostname (e.g. macmini.customdomain.com) that will be automatically updated.
Set up a free SSL certificate from Let’s Encrypt that you can use to access web interfaces running on that computer dynamically.
Have that SSL cert be automatically renewed so it never expires.
Google Domains. It offers free Dynamic DNS hosting,
https://medium.com/@jeremygale/how-to-set-up-a-free-dynamic-hostname-with-ssl-cert-using-google-domains-58929fdfbb7a


Google Domains Security: https://domains.google/tld/security/

Google Domains: Use Hypertext Transfer Protocol Secure (HTTPS) on your domain
https://support.google.com/domains/answer/7630973?hl=en

Certbot for Ubuntu 20 running Nginx
https://certbot.eff.org/instructions?ws=nginx&os=ubuntufocal

Search SSL certificates
https://search.censys.io/certificates


https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/


## Just for fun: "Trap Hackers in Your Server"

Divulged on Wolfgang's channel, setting up this script will deviate some automated hacker attacks to port 22 via the Endlessh created by Christopher Wellons: https://github.com/skeeto/endlessh

For a full explanation of how this works, you can watch the short but sweet video at Wolfgang's channel here: https://www.youtube.com/watch?v=SKhKNUo6rJU&ab_channel=Wolfgang%27sChannel

Disclaimer: I am not an expert on remote development and you should do your own research to make sure that everything in this and my other guides, blogposts, etc. are safe before implementing them yourself. By following this an other guides, blogposts, etc. of mine I shall not be held accountable for any loss of information, assets, or any damage related resulting from them including, but not limited, to loss of data, assets, external hackers getting into your systems, etc. All of the information here has been provided in good faith and you can freely make use of it and distribute it under a CC BY 2.0 license (https://creativecommons.org/licenses/by/2.0/), except for the code for which you should consult the original licenses whenever a commentary or link appears, or under an open MIT license whenever the code is mine as indicated by a lack of commentary or link in which case the following text applies:

MIT License

Copyright (c) 2022 Damian Y. Romero Diaz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


# Other Resources

To learn more about what IDEs are 
Good IDE
https://ninja-ide.org/best-python-ides-ubuntu-20-04/


Lj's blogpost
https://ljvmiranda921.github.io/notebook/2020/11/15/data-science-swe/

Git large file storage
https://git-lfs.github.com/

Duck DNS
https://www.duckdns.org/

FastAPI Cheatsheet
https://gitlab.com/euri10/fastapi_cheatsheet

Guidelines: Formal recommendations or principles to assist with patient care for specific clinical circumstances.
    Potential impact in clinical settings and research beyond this study

REDATA:
Add:
    Study materials are/will be shared via an open access repository
    Study data are/will be posted in an open access repository
Remind Gray for IRB number


Recorded telephone coaching sessions (approximately 24,500) in English and Spanish from 1205 women participating in the 




HTML and CSS for Python Developers
https://realpython.com/html-css-python/

Using FastAPI to Build Python Web APIs
https://realpython.com/fastapi-python-web-apis/

Build a URL Shortener With FastAPI and Python
https://realpython.com/build-a-python-url-shortener-with-fastapi/


External GPU on Ubuntu Server 20.04
https://www.sseongha.com/post/egpu/
https://alex-vaith.medium.com/this-is-why-you-want-to-consider-an-egpu-for-deep-learning-on-your-mobile-work-station-a26dc9ed8673